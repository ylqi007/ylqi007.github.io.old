---
layout: post
title: 大话数据结构(ing)--查找
category: 数据结构
tags: "Data-Structure"
---

# 第8章 查找

## 8.2 查找概论
> 查找表(Search Table)是由同一类型的数据元素（或记录）构成的集合；
> 关键字(Key)是数据元素中某个数据项的值，又称为键值，用它可以标识一个数据元素；
> 1. 若此关键字可以唯一地标识一个记录，则称此关键字为主关键字(Primary Key);
> 2. 可以识别多个数据元素（或记录）的关键字，称之为次关键字(Secondary Key)。
> 
> **查找(Searching)就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。**
> 
> 查找表按照操作方式可以分为：
> 1. 静态查找表(Static Search Table)，只做查找操作的查找表
> 2. 动态查找表(Dynamic Search Table)，在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。

## 8.3 顺序表查找
> 顺序查找(Sequential Search)又叫线性查找，是最基本的查找技术。

### 8.3.1 顺序表查找算法

### 8.3.2 顺序表查找优化
> 设置“哨兵”。
> 时间复杂度为 $O(n)$
> **缺点：** 当$n$很大的时候，查找效率极为低下；
> **优点：** 算法简单，可用于小型的数据查找。

## 8.4 有序表查找
> 一个线性表有序时，对于查找总有很大帮助。

### 8.4.1 折半查找
> 折半查找(Binary Search)技术，又称为二分查找。它的前提时线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。
> 时间复杂度为 $O(n \log n)$，它显然远远好于顺序查找的$O(n)$时间复杂度。
> 适用于静态查找，因为只需要一次排序；对于动态查找表，不建议使用。

### 8.4.2 插值查找
> 插值查找(Interpolation Search)是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心在于插值的计算公式$\frac{key-a[low]}{a[high]-a[low]}$。
> 时间复杂度为 $O(n \log n)$
> 对于表长比较大，而且关键字分布又比较均匀的查找表，插值查找算法的平均性能比折半查找要好很多。但是对于极端不均匀的数据，用插值查找未必是很合适的选择。

### 8.4.3 斐波那契查找
> 斐波那契查找(Fibonacci Search)，它是利用黄金分割原理实现的。
> 斐波那契查找算法的核心在于：
> 1. 当$key=nums[mid]$时，查找成功；
> 2. 当$key<nums[mid]$时，新范围是第$low$个到第$mid-1$个，此时范围个数为$F[k-1]-1$个；
> 3. 当$key>nums[mid]$时，新范围是第$mid+1$个到第$high$个，此时范围个数为$F[k-2]-1$个。
> ![4.6.1](/public/img/posts/DataStructure/DaHuaShuJuJieGou/8.1.png)

## 8.5 线性搜索查找
> **索引**就是把一个关键字与它对应的记录相关联的过程。
> 索引按照结构可以分为线性索引、树形索引和多级索引。
> 线性索引就是将索引项集合组织为线性结构，也成为索引表。

### 8.5.1 稠密索引
> 稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项。对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排序。

### 8.5.2 分块索引
> 分块有序，是把数据集的记录分成若干块，并且这些块需要满足两个条件：
> 1. 块内无序
> 2. 块间有序

### 8.5.3 倒排索引
> 索引项的通用结构
> * 次关键码
> * 记录号表

## 8.6 二叉树排序
> 二叉树(Binary Sort Tree)，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。
> * 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
> * 若他的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
> * 它的左、右子树也分别为二叉排序树。
> 
> 构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。

### 8.6.1 二叉排序树查找操作

### 8.6.2 二叉排序树插入操作

### 8.6.3 二叉排序树删除操作
> 不能因为删除了结点，而让这棵树变得不满足二叉排序树的特性，所以删除需要考虑多种情况。
> 1. 删除叶子结点 => 对整棵树无影响
> 2. 删除的结点只有左子树或右子树 => 独子继承父业
> 3. 删除的结点有左右子树 => 前驱、后继代替

### 8.6.4 二叉排序树总结
> 二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需要修改链接指针即可。

## 8.7 平衡二叉树(AVL树)
> 平衡二叉树(Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree)，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多为$1$。

### 8.7.1 平衡二叉树实现原理
> 构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各个结点之间的链接关系，进行相应的旋转，使之称为新的平衡子树。

### 8.7.2 平衡二叉树实现算法
> 如果需要查找的集合本身没有顺序，在频繁查找的同时，也需要经常插入和删除操作，显然需要构建二叉排序树，但是不平衡的二叉排序树，查找效率非常低。平衡二叉树的查找时间时间复杂度就为$O(\log n)$，而插入和删除也为$O(\log n)$。

## 8.8 多路查找树(B树)
> 为了降低对外存设备的访问次数，需要新的数据结构。
> 多路查找树(multi-way search tree)，其每一个结点的孩子数可以多于两个，且每个结点处可以存储多个元素。此时，每一个结点可以存储多少个元素，以及它的孩子数的多少是非常关键的。

### 8.8.1 2-3树
> 2-3树：每一个几点都具有两个孩子（称为2结点）或者三个孩子（称为3结点）。
> * 一个$2$结点包含一个元素和两个孩子（或者没有孩子，不能只有一个孩子）。
> * 一个$3$结点包含一小一大两个元素和三个孩子（或者没有孩子）。

### 8.8.2 2-3-4树

### 8.8.3 B树
> B树(B-tree)是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶(order)。
> 一个$m$阶的B树具有如下属性：
> * 如果根结点不是叶子结点，则其至少有两棵子树。
> * 每一个非根的分支结点都有$k-1$个元素和$k$个孩子，其中$\lceil m/2 \rceil \leqslant k \leqslant m$。每一个叶子几点$n$都有$k-1$个元素，其中$\lceil m/2 \rceil \leqslant k \leqslant m$。
> * 所有叶子结点都位于同一个层次。
> 
> 在B树上查找的过程是一个顺指针查找结点和在节点中查找关键字的交叉过程。

### 8.8.4 B+树
> 一棵$m$阶的B+树和$m$阶的B树的差异在于：
> * 有$n$棵子树的结点中包含有$n$个关键字；
> * 所有的叶子结点包含全部关键字的信息，及指向包含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接；
> * 所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字。

## 8.9 散列表查找(哈希表)概述
> 能否直接通过关键字key得到要查找的记录内存存储位置？

### 8.9.1 散列表查找定义
> 散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系$f$，使得每个关键字key对应一个存储位置$f(key)$。查找时，根据这个确定的对应关系找到给定值$key$的映射$f(key)$。
> 对应关系$f$称为散列函数，又称为哈希(hash)函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。关键字对应的记录存储位置称为散列地址。

### 8.9.2 散列表查找步骤
> 散列技术最适合的求解问题是查找与给定值相等的记录。

## 8.10 散列函数的构造方法
> 好的散列函数满足两个原则：
> 1. 计算简单
> 2. 散列地址分布均匀

### 8.10.1 直接定址法

### 8.10.2 数字分析法

### 8.10.3 平方取中法

### 8.10.4 折叠法

### 8.10.5 除留余数法

### 8.10.6 随机数法

## 8.11 处理散列冲突的方法
### 8.11.1 开放定址法
> 开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。

### 8.11.2 再散列函数法

### 8.11.3 链地址法

### 8.11.4 公共溢出区法

## 8.12 散列表查找实现

### 8.12.1 散列表查找算法实现

### 8.12.2 散列表查找性能分析








