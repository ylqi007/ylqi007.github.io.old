---
layout: post
title: 大话数据结构(ing)
category: 数据结构
tags: "Data-Structure"
---
# 大话数据结构

### 1.5.1 逻辑结构
逻辑结构：指数据对象中数据元素之间的相互关系。
1. 集合结构
2. 线性结构
3. 树形结构
4. 图形结构

### 1.5.2 物理结构（存储结构）
物理结构是指数据的逻辑结构在计算机中的存储形式。
1. 顺序存储结构：把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系是一致的。
2. 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以连续，也可以是不连续的。


## 1.6 抽象数据类型

### 1.6.1 数据类型
数据类型是指一组性质相同的值的集合以及定义在此集合上的一些操作的总称。
抽象是指抽取出事物具有的普遍性的本质。

### 1.6.2 抽象数据类型（ADT）
是指一个数据模型及定义在该模型上的一组操作。


---
# 线性表

## 3.2 线性表的定义
Def：线性表（List）：零个或多个数据元素的有限序列。
* 是一个序列，也就是说，元素之间是有**顺序**的（第一个元素无前驱，最后一个元素无后继，其他每个元素只有一个前驱和一个后继）。
* **有限**

## 3.3 线性表的抽象数据类型
Data + Operations

## 3.4 线性表的顺序存储结构

### 3.4.1 顺序存储定义
线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

### 3.4.2 顺序存储方式
用一维数组来实现顺序存储结构。
三个属性：
* 存储空间的起始位置
* 线性表的最大存储容量
* 线性表的当前长度

### 3.4.3 数据长度与线性表长度的区别
数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般不变的。
线性表的长度是线性表中数据元素的个数，随着线性表的插入和删除的进行，这个量是变化的。

### 3.4.4 地址计算方法
存储器中的每个存储单元都有自己的编号，这个编号称为**地址**。
每个数据元素占用$c$个存储单元，则有
$LOC(a_{i+1})=LOC(a_{i})+c$
$LOC(a_{i})=LOC(a_{1})+(i-1)\times c$
存取时间性能为$O(1)$，通常把具有这一特点的存储结构称为**随机存储结构**。

## 3.5 顺序存储结构的插入与删除

### 3.5.1 获得元素操作
返回数组第$i-1$下标的值。

### 3.5.2 插入操作
插入算法思路：
* 如果插入位置不合理，抛出异常；
* 如果线性表长度大于等于数组长度，抛出异常或动态增加容量；
* 从最后一个元素开始向前遍历到第$i$个位置，分别将它们向后移动一个位置；
* 将要插入元素填入位置$i$处；
* 线性表长度加1。

### 3.5.3 删除操作
删除算法思路：
* 如何删除位置不合理，抛出异常；
* 取出删除元素；
* 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；
* 线性表的长度减1

插入和删除的时间复杂度：
* 最好情况，插入和删除在最后一个位置，此时时间复杂度为$O(1)$
* 最坏情况，插入和删除在第一个位置，此时时间复杂度为$O(n)$
* 平均移动次数为$(n-1)/2$
* 所以平均时间复杂度为$O(n)$

线性表的顺序存储结构：
* 存、读数据 ==> $O(1)$
* 插入或删除 ==> $O(n)$
说明比较适合元素个数变化不大，而且更多是存取数据的应用。

### 3.5.4 线性表顺序存储结构的优缺点
* 优点
	* 无须为表示表中元素之间的逻辑关系而增加额外的存储空间；
	* 可以快速的存取表中任意位置的元素
* 缺点
	* 插入和删除操作需要移动大量元素
	* 当线性表长度变化较大时，难以确定存储空间的容量
	* 造成存储空间的“碎片”


## 3.6 线性表的链式存储结构
### 3.6.1 顺序存储结构不足的解决办法
如何解决插入和删除时需要移动大量元素。

### 3.6.2 线性表链式存储结构定义
为方便对链表进行操作，在单链表的第一个节点前附设一个节点，称为**头节点**。头节点的数据域可以不存任何信息，也可以存线性表的长度等附加信息。

### 3.6.3 头指针与头节点的异同
* 头指针
* 头节点
不带头节点的单链表中，头指针指向第一个节点；带有头节点的单链表中，头指针指向头节点。

### 3.6.4 线性表链式存储结构代码描述
节点由存储数据元素的数据域和存放后继节点的地址的指针域组成。


## 3.7 单链表的读取
获取链表第$i$个数据的算法思路：
1. 声明一个节点p指向链表的第一个节点，初始化j从1开始；
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个节点，j累加1；
3. 若到链表末尾p为空，则说明第$i$个元素不存在；
4. 否则查找成功，返回节点p的数据。

* 最好情况 ==> $O(1)$
* 最坏晴空 ==> $O(n)$

由于单链表的结构中没有定义表长，所以不能事先知道要循环多少次，因此不便使用for循环。其主要核心思想是“**工作指针后移**”。

## 3.8 单链表的插入与删除
### 3.8.1 单链表的插入
单链表第$i$个数据插入节点的算法思路：
1. 声明一个节点p指向链表第一个节点，初始化j从1开始；
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个节点，j累加1；
3. 若到链表末尾p为空，则说明第$i$个元素不存在；
4. 否则查找成功，在系统中生成一个空节点s；
5. 将数据元素e赋给`s.data`；
6. 单链表的插入标准语句`s.next=p.next; p.next=s`;
7. 返回成功。

### 3.8.2 单链表的删除
单链表第$i$个数据删除节点的算法思路：P64

单链表的插入和删除算法包含两部分：
1. 遍历查找第$i$个元素；
2. 插入和删除元素。

对于插入或删除数据越频繁的操作，单链表的效率优势越明显。

## 3.9 单链表的整表创建
顺序存储结构的构建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。
单链表的创建，空间的大小和位置不需要预先分配，根据系统的情况和实际需求即时生成。所以单链表创建的过程就是一个动态生成链表的过程，即从“空表”的初始状态，依次建立各个元素节点，并逐个插入链表。
单链表整表创建思路：P66
* 头插法
* 尾插法

## 3.10 单链表的整表删除
思路：P69

## 3.11 单链表结构与顺序存储结构优缺点
* 存储分配方式
	* 顺序，一段连续存储单元
	* 单链表，任意的存储单元
* 时间性能
	* 查找
	* 插入／删除
* 空间性能

经验性结论：
* 若线性表需要频繁查找，很少插入／删除时，宜采用顺序存储结构；若需要频繁插入／删除时，宜采用单链表结构。==> 游戏开发用户注册vs装备列表
* 当线性表中的元素个数变化较大或者根本不知道多大时，最好用单链表结构，因为这样不需要考虑存储空间大小的问题。

## 3.12 静态链表
用数组描述的链表叫**静态链表**。
***对最后一个元素的cur不理解？？？***

### 3.12.1 静态链表的插入操作
关键：如何用静态模拟动态链表结构的存储空间的分配，需要是申请，无用时分配。

### 3.12.2 静态链表的删除操作

### 3.12.3 静态链表的优缺点
* 优点
	* 插入／删除时，只需修改游标，不需移动元素
* 缺点
	* 没有解决表长难以确定的问题
	* 失去了顺序结构存储随机存取的特性

### 3.12.3 循环链表
将单链表中终端节点的指针由空指针改为指向头节点，就使整个单链表形成一个环，这种头尾相接的单链表称为**单循环链表**，简称循环链表(circular linked list)。
为了是空链表与非空链表处理一致，通常设一个头节点(并不是必须要头节点)。
为了用$O(1)$的时间由链表指针访问到最后一个节点，用指向终端节点的尾指针(rear)表示循环链表，此时查找开始节点和终端节点都很方便。e.g.如果要将两个循环链表合并时，有了尾指针会非常简单。

## 3.14 双向链表
单链表中，有next指针，这使得查找下一个节点的时间复杂度为$O(1)$，但是要查找上一个节点的时间复杂度就是$O(n)$。 于是设计出了双向链表。
双向链表(double linked list)是在单链表的每个节点中，再设置一个指向其前驱节点的指针域。

## 3.15 总结
线性表
1. 顺序存储结构
2. 链式存储结构
	1. 单链表
	2. 静态链表
	3. 循环链表
	4. 双向链表







