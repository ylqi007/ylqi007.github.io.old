---
layout: post
title: 大话数据结构(ing)
category: 数据结构
tags: "Data-Structure"
---
# 大话数据结构

### 1.5.1 逻辑结构
逻辑结构：指数据对象中数据元素之间的相互关系。
1. 集合结构
2. 线性结构
3. 树形结构
4. 图形结构

### 1.5.2 物理结构（存储结构）
物理结构是指数据的逻辑结构在计算机中的存储形式。
1. 顺序存储结构：把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系是一致的。
2. 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以连续，也可以是不连续的。


## 1.6 抽象数据类型

### 1.6.1 数据类型
数据类型是指一组性质相同的值的集合以及定义在此集合上的一些操作的总称。
抽象是指抽取出事物具有的普遍性的本质。

### 1.6.2 抽象数据类型（ADT）
是指一个数据模型及定义在该模型上的一组操作。


---
# 2. 算法

## 2.2 数据结构与算法关系
将**数据结构**和**算法**结合才可以更深的理解并解决问题。

## 2.4 算法定义
**算法**是解决特定问题求解步骤的描述，在计算机中变现为指令的有限序列，并且每条指令表示一个或多个操作。

## 2.5 算法的特性
算法具有五个基本特性：
1. 输入 ==> 算法具有零个或多个输入；
2. 输出 ==> 算法**至少有一个**或多个输入；
3. 有穷性 ==> 指算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。
4. 确定性 ==> 算法的每一个步骤都具有确定的含义，不会出现二义性。
5. 可行性 ==> 算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

## 2.6 算法设计的要求
### 2.6.1 正确性
指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。

### 2.6.2 可读性
为了便于阅读、理解和交流。

### 2.6.3 健壮性
当输入数据不合法时，算法也能够做出相关处理，而不是产生异常或莫名奇妙的结果。

### 2.6.4 时间效率高和存储量低

## 2.7 算法效率的度量方法
### 2.7.1 事后统计方法
这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。
* 必须提前根据算法编好程序 ==> 费时费力
* 时间比较依赖与计算机硬件和软件等环境因素，可能会掩盖算法本身的优劣
* 算法的测试数据设计困难

### 2.7.2 事前分析估算方法
在计算机编制前，依据统计方法对算法进行估计。
一个高级程序语言编写的程序在计算机上的运行所消耗的时间取决于下列因素：
1. 算法采用的策略、方法 ==> **算法好坏的根本**
2. 编译产生的代码量
3. 问题的输入规模
4. 机器执行指令的速度

抛开环境因素，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。

## 2.8 函数的渐进增长
> **函数的渐进增长**：给定两个函数$f(n)$和$g(n)$，如果存在一个整数$N$，使得对于所有的$n>N$，$f(N)$总是比$g(n)$大，那么，我们说$f(n)$的增长渐进快于$g(N)$。
* 忽略加法常数；
* 于最高次项相乘的常数并不重要；

最高次项的指数大的，函数随着$n$的增长，结果也会变得增长特变快。

## 2.9 算法时间复杂度
### 2.9.1 算法时间复杂度定义
> 在进行算法分析时，语句总的执行次数$T(n)$是关于问题规模$n$的函数，进而分析$T(n)$随$n$的变换情况并确定$T(n)$的数量级。算法的时间复杂度，也就是算法的时间度量，记作：$T(n)$=$O(f(n))$。它表示随问题规模$n$的增大，算法执行时间的增长率和$f(n)$的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。其中$f(n)$是问题规模$n$的某个函数。

 这种用$O(\ )$来体现算法时间复杂度的记法，称之为**大O记法**。

### 2.9.2 推导大O阶方法

## 2.10 常见的时间复杂度
常用的时间复杂度所消耗的时间从小到大依次是：
$O(1)<O(log\ n)<O(n)<O(n\ log\ n)<O(n^{2})<O(n^{3})<O(2^{n})<O(n !)<O(n^{n})$

## 2.11 最坏情况与平均情况
最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。
平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。

## 2.12 算法空间复杂度
算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：**$S(n)=O(f(n))$**，其中，$n$为问题的规模，$f(n)$为语句关于$n$关于$n$所占存储空间的函数。

---
# 3. 线性表

## 3.2 线性表的定义
Def：线性表（List）：零个或多个数据元素的有限序列。
* 是一个序列，也就是说，元素之间是有**顺序**的（第一个元素无前驱，最后一个元素无后继，其他每个元素只有一个前驱和一个后继）。
* **有限**

## 3.3 线性表的抽象数据类型
Data + Operations

## 3.4 线性表的顺序存储结构

### 3.4.1 顺序存储定义
线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

### 3.4.2 顺序存储方式
用一维数组来实现顺序存储结构。
三个属性：
* 存储空间的起始位置
* 线性表的最大存储容量
* 线性表的当前长度

### 3.4.3 数据长度与线性表长度的区别
数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般不变的。
线性表的长度是线性表中数据元素的个数，随着线性表的插入和删除的进行，这个量是变化的。

### 3.4.4 地址计算方法
存储器中的每个存储单元都有自己的编号，这个编号称为**地址**。
每个数据元素占用$c$个存储单元，则有
$LOC(a_{i+1})=LOC(a_{i})+c$
$LOC(a_{i})=LOC(a_{1})+(i-1)\times c$
存取时间性能为$O(1)$，通常把具有这一特点的存储结构称为**随机存储结构**。

## 3.5 顺序存储结构的插入与删除

### 3.5.1 获得元素操作
返回数组第$i-1$下标的值。

### 3.5.2 插入操作
插入算法思路：
* 如果插入位置不合理，抛出异常；
* 如果线性表长度大于等于数组长度，抛出异常或动态增加容量；
* 从最后一个元素开始向前遍历到第$i$个位置，分别将它们向后移动一个位置；
* 将要插入元素填入位置$i$处；
* 线性表长度加1。

### 3.5.3 删除操作
删除算法思路：
* 如何删除位置不合理，抛出异常；
* 取出删除元素；
* 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；
* 线性表的长度减1

插入和删除的时间复杂度：
* 最好情况，插入和删除在最后一个位置，此时时间复杂度为$O(1)$
* 最坏情况，插入和删除在第一个位置，此时时间复杂度为$O(n)$
* 平均移动次数为$(n-1)/2$
* 所以平均时间复杂度为$O(n)$

线性表的顺序存储结构：
* 存、读数据 ==> $O(1)$
* 插入或删除 ==> $O(n)$
说明比较适合元素个数变化不大，而且更多是存取数据的应用。

### 3.5.4 线性表顺序存储结构的优缺点
* 优点
	* 无须为表示表中元素之间的逻辑关系而增加额外的存储空间；
	* 可以快速的存取表中任意位置的元素
* 缺点
	* 插入和删除操作需要移动大量元素
	* 当线性表长度变化较大时，难以确定存储空间的容量
	* 造成存储空间的“碎片”


## 3.6 线性表的链式存储结构
### 3.6.1 顺序存储结构不足的解决办法
如何解决插入和删除时需要移动大量元素。

### 3.6.2 线性表链式存储结构定义
为方便对链表进行操作，在单链表的第一个节点前附设一个节点，称为**头节点**。头节点的数据域可以不存任何信息，也可以存线性表的长度等附加信息。

### 3.6.3 头指针与头节点的异同
* 头指针
* 头节点
不带头节点的单链表中，头指针指向第一个节点；带有头节点的单链表中，头指针指向头节点。

### 3.6.4 线性表链式存储结构代码描述
节点由存储数据元素的数据域和存放后继节点的地址的指针域组成。


## 3.7 单链表的读取
获取链表第$i$个数据的算法思路：
1. 声明一个节点p指向链表的第一个节点，初始化j从1开始；
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个节点，j累加1；
3. 若到链表末尾p为空，则说明第$i$个元素不存在；
4. 否则查找成功，返回节点p的数据。

* 最好情况 ==> $O(1)$
* 最坏晴空 ==> $O(n)$

由于单链表的结构中没有定义表长，所以不能事先知道要循环多少次，因此不便使用for循环。其主要核心思想是“**工作指针后移**”。

## 3.8 单链表的插入与删除
### 3.8.1 单链表的插入
单链表第$i$个数据插入节点的算法思路：
1. 声明一个节点p指向链表第一个节点，初始化j从1开始；
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个节点，j累加1；
3. 若到链表末尾p为空，则说明第$i$个元素不存在；
4. 否则查找成功，在系统中生成一个空节点s；
5. 将数据元素e赋给`s.data`；
6. 单链表的插入标准语句`s.next=p.next; p.next=s`;
7. 返回成功。

### 3.8.2 单链表的删除
单链表第$i$个数据删除节点的算法思路：P64

单链表的插入和删除算法包含两部分：
1. 遍历查找第$i$个元素；
2. 插入和删除元素。

对于插入或删除数据越频繁的操作，单链表的效率优势越明显。

## 3.9 单链表的整表创建
顺序存储结构的构建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。
单链表的创建，空间的大小和位置不需要预先分配，根据系统的情况和实际需求即时生成。所以单链表创建的过程就是一个动态生成链表的过程，即从“空表”的初始状态，依次建立各个元素节点，并逐个插入链表。
单链表整表创建思路：P66
* 头插法
* 尾插法

## 3.10 单链表的整表删除
思路：P69

## 3.11 单链表结构与顺序存储结构优缺点
* 存储分配方式
	* 顺序，一段连续存储单元
	* 单链表，任意的存储单元
* 时间性能
	* 查找
	* 插入／删除
* 空间性能

经验性结论：
* 若线性表需要频繁查找，很少插入／删除时，宜采用顺序存储结构；若需要频繁插入／删除时，宜采用单链表结构。==> 游戏开发用户注册vs装备列表
* 当线性表中的元素个数变化较大或者根本不知道多大时，最好用单链表结构，因为这样不需要考虑存储空间大小的问题。

## 3.12 静态链表
用数组描述的链表叫**静态链表**。
***对最后一个元素的cur不理解？？？***

### 3.12.1 静态链表的插入操作
关键：如何用静态模拟动态链表结构的存储空间的分配，需要是申请，无用时分配。

### 3.12.2 静态链表的删除操作

### 3.12.3 静态链表的优缺点
* 优点
	* 插入／删除时，只需修改游标，不需移动元素
* 缺点
	* 没有解决表长难以确定的问题
	* 失去了顺序结构存储随机存取的特性

### 3.12.3 循环链表
将单链表中终端节点的指针由空指针改为指向头节点，就使整个单链表形成一个环，这种头尾相接的单链表称为**单循环链表**，简称循环链表(circular linked list)。
为了是空链表与非空链表处理一致，通常设一个头节点(并不是必须要头节点)。
为了用$O(1)$的时间由链表指针访问到最后一个节点，用指向终端节点的尾指针(rear)表示循环链表，此时查找开始节点和终端节点都很方便。e.g.如果要将两个循环链表合并时，有了尾指针会非常简单。

## 3.14 双向链表
单链表中，有next指针，这使得查找下一个节点的时间复杂度为$O(1)$，但是要查找上一个节点的时间复杂度就是$O(n)$。 于是设计出了双向链表。
双向链表(double linked list)是在单链表的每个节点中，再设置一个指向其前驱节点的指针域。

## 3.15 总结
线性表
1. 顺序存储结构
2. 链式存储结构
	1. 单链表
	2. 静态链表
	3. 循环链表
	4. 双向链表


---
# 4. 栈和队列
**栈**是限定仅在表尾进行插入和删除操作的线性表；
**队列**是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。

## 4.2 栈的定义
**栈**是限定仅在表尾进行插入和删除操作的线性表。
* 栈顶(top)，允许插入和删除的一端；
* 栈底(bottom)，
* 空栈，不含任何数据元素的栈。

**栈**又称为后进先出(Last In First Out)的线性表，简称LIFO结构。

栈的插入操作，叫做进栈、压栈或入栈；
栈的删除操作，叫做出栈或弹栈。

### 4.2.2 进栈出栈的变化形式


## 4.3 栈的抽象数据类型
栈是线性表的一种，但其操作有一定的特殊性，将栈的插入和删除操作更名为push和pop。

### 4.4 栈的顺序结构存储及实现
### 4.4.1 栈的顺序存储结构
数组实现，下标为0的一端做栈底。

### 4.4.2 栈的顺序存储结构--进栈操作

### 4.4.3 栈的顺序存储结构--出栈操作

## 4.5 两栈共享空间
顺序存储的实现有意很大缺陷，就是必须事先确定数组存储空间大小，扩容麻烦。

如果有两个类型相同的栈，可以用一个数组来存储两个栈：

![4.5.1](/public/img/posts/DataStructure/DaHuaShuJuJieGou/4.5.1.png)

* 若栈2是空栈，栈1的top1等于n-1时，就是栈1满了；
* 若栈1是空栈，栈2的top2等于0时，就是栈2满了；
* 更多情况是两个栈见面之时，也就是两个指针之间相差1时，即top1 + 1 == top2为栈满。

事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系的时候，也就是一个栈增长时，一个栈缩短的情况。

## 4.6 栈的链式存储结构及实现
链栈
通常对于链栈来说，不需要头指针，因为已经有栈顶在头部了。

![4.6.1](/public/img/posts/DataStructure/DaHuaShuJuJieGou/4.6.1.png)


## 4.7 栈的应用

## 4.8 栈的应用--递归
栈有一个很重要的应用：在程序设计语言中实现了递归。
把一个直接调用自己或者通过一系列的调用语句间接的调用自己的函数，称为**递归函数**。每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值并退出。

## 4.9 栈的应用--四则运算表达式求值
### 4.9.1 后缀（逆波兰）表示法定义
波兰逻辑学家提出的一种不需要括号的后缀表达法，称为逆波兰(Reverse Polish Notation, RPN)。
规则：从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。

### 4.9.3 中缀表达式转后缀表达式
规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即称为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或是优先级低于栈顶符号，则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。

计算机处理标准表达式分为两步：
1. 将中缀表达式转化为后缀表达式（栈用来进出运算符号）；
2. 将后缀表达式进行运算得到寄过（栈用来进出数字）。

## 4.10 队列的定义
队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。

队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。

## 4.12 循环队列
### 4.12.1 队列顺序存储的不足
入队操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为$O(1)$.
与栈不同的是，队列元素的出列在队头，队列中的所有元素都需要向前移动，以保证队列的队头的下标为0。
如果不限制队列的元素必须存储在数组的前$n$个单元这一条件，出队的性能就会大大增加。

### 4.12.2 循环队列定义
循环队列：头尾相接的顺序存储结构。
当front==rear时，如何判读队列时空的还是满的？
1. 设置标志变量flag
2. 当队列空时，条件为front==rear；当队列满时，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。

## 4.13 队列的链式存储结构及实现
队列的链式存储结构，其实就是线性表的单链表，只不过它只能在尾部进入，头部输出而已，简称为链队列。

